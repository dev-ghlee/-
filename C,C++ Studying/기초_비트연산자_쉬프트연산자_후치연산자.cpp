//#붙은것은 전처리기 : #include : 헤더파일을 여기에 포함시키는 기능
#include <iostream>

//c++ 표준기능의 대부분은 std라는 namespace 안에 존재함. 이름이 겹치는 것 방지

using namespace std;

int main(int argc, char* argv[]) {
                                       //   2진수
    const int iAttack = 0x00000001;    //     1
    const int iArmor = 0x00000002;     //    10
    const int iHP = 0x00000004;        //   100
    const int iMP = 0x00000002;        //  1000
    const int iCritical = 0x00000010;  // 10000
    // 16진수를 2진수로 바꾸고 그것에대한 10진수 값을 변수에 대입함, 보라색으로 써있는 게 16진수
    //1번째 처럼 쓰는 것
    // => int는 4byte, 즉, 32bit. 보라색 저기 숫자 하나당 4bit
    // 그래서 00000011이러면 2진수로 00010001 임.
    
        
    //0x를 붙이면 16진수를 10진수로 변환해서 계산값에 넣겠습니다. 
    //라는 뜻
    
    int iBuf = iAttack | iHP | iCritical; // 10101 -> 버프를 건거임.
    cout << " Attack 버프가 걸려있는가 : " << (iBuf & iAttack) <<endl; // 비트 연산을 통해 버프 걸려있는지 확인  => 10101 & 1 => 00001 True
    cout << " armor 버프가 걸려있는가 : " << (iBuf & iArmor) <<endl;
    cout << " HP 버프가 걸려있는가 : " << (iBuf & iHP) <<endl;
    cout << " MP 버프가 걸려있는가 : " << (iBuf & iMP) <<endl;
    cout << " Critical 버프가 걸려있는가 : " << (iBuf & iCritical) <<endl;
    
    
    
    
    // 연산자 축약형 : 연산자를 줄여서 사용할 수 있음.
    // int iBuf ^= iHP; XOR 사용
    // 위를 풀어서 쓰면 iBuf = iBuf ^ iHP;
    // 10101 ^ = 00100 = 10001  
    // 쓰다 보니 XOR( ^ )은 1을 키고 끌 때 사용.
    // 그래서 걸려있는 버프를 끌때는 이 XOR을 이용하여 끈다.
    
    //버프 끄기
    iBuf ^= iHP; //버프 끄기 연산
    cout << " HP 버프가 걸려있는가 : " << (iBuf & iHP) <<endl;
    
    //버프 다시 키기
    iBuf ^=iHP; //버프 다시 키기 연산
    cout << " HP 버프가 걸려있는가 : " << (iBuf & iHP) <<endl;
    
    //----------------------------
    //쉬프트 연산
    //응용
    //비트필드, 변수를 비트단위로 쪼개서 쓰기
    int iHigh = 187;
    int iLow = 13560;
    
    int iNumber = iHigh;
    // iNumber에는 187이 들어가있다. 이값을 <- 방향으로 16피트 이동시키면 상위 16비트에 값이 들어가게 된다.
    iNumber <<= 16;
    
    //하위 16비트를 채운다.
    iNumber |= iLow;
    
    //High 값을 출력한다.
    cout <<"high : "<< (iNumber>>16) <<endl;
    cout <<"low : " << (iNumber & 0x0000ffff) <<endl;
    
    //------------------------------
    //기본
	// std::cout << "Hello, goorm!" << std::endl;
	// cout << "Hello, goorm!"  
	// << "hi" << endl;
    
	// int num = 0;
	// cout<<"숫자를 입력하세요 : ";
	// cin >> num;
    
    
    
	// cout<<"10~20 : " << (10<=num && num<=20)<<endl;
	// cout<<"87 & 53 : " << (87 & 53)<<endl  ;
	return 0;
    
// ------------------------------------------------------------ 
    
    /*
    2진수 : 0~1
    8진수 : 0 ~ 7
    10진수 : 0 ~9
    16진수 : 0 ~15 , 0~9  10~15 : a~f
    진수들은 서로 다른 지수로 변환 가능
    87을 2진수, 16진수로 변환
    2진수 : 1010111 이 됨. 
    
    16진수로 변환 -> 2진수로 변환한 후 16진수로 바꾸는 것이 더 쉬움.
    오룬쪽으로부터 2진수를 4자리씩 끊어서 계산한다. 16진수 1자리는 2진수 4자리
    0101 0111 
    8421 8421    4자리가 안되는 자리는 0으로 채운다. 8421 저렇게 코드를 매김.
    2진수가 1인 부분의 값들을 더한다.
    따라서 16진수 : 57
    
    -------------------------------------------------------------------------
    
    <비트단위 논리연산자> : 2진수 단위의 연산을 한다. 값 대 값을 연산하여 값으로 나온다.
    종류 : AND(&), OR(|), NOT(~), XOR(^)
    A B XOR
    0 0  0
    1 0  1 
    0 1  1
    1 1  0
    
    ex) AND 해보기
    87 & 53 =
    87 : 1010111    
    53 : 110101
    
    먼저 위처럼 2진수로 바꾼 후에 2진수 각 자리별로 논리연산 실행
    오른쪽에 선을 맞추고, 자릿수가 안맞으면 왼쪽 0추가.
    
    1010111
   &0110101        &자리에 | , ~ , ^ 들어가면 됨.
   ---------
  =>0010101    앞에 0 때면 10101
  10진수로 변환하면 21이 나옴.
  따라서 87 & 53 = 21
  
  이와 마찬가지로 OR, NOT, XOR 하면 된다.
  
  이 비트단위 논리연산자는 게임의 어디에 쓰일까...?
  버프를 저장할때 사용한다든지...?
  
  -------------------------------------------------------------------
  
  <상수> 변하지 않는 수, 값을 한번 지정하면 바꿀 수 없는 
        선언과 동시에 값을 지정해야함.
        
        
    const int iAttack = 0x
          헝가리언 표기법 , 이 변수가 어떤 타입을 나타내는지에 대한 
          약어를 앞에 붙인다. int 는 n이나 i  
          10진수와 16진수 구분을 위해 16진수는 0x를 붙임. 
          
                                       //   2진수
    const int iAttack = 0x00000001;    //     1
    const int iArmor = 0x00000002;     //    10
    const int iHP = 0x00000004;        //   100
    const int iMP = 0x00000002;        //  1000
    const int iCritical = 0x00000010;  // 10000
    // 16진수를 2진수로 바꾸고 그것에대한 10진수 값을 변수에 대입함, ox옆에 써있는 게 16진수
    //1번째 처럼 쓰는 것
    // => int는 4byte, 즉, 32bit. 보라색 저기 숫자 하나당 4bit
    // 그래서 00000011이러면 2진수로 00010001 임.
    
        
    //0x를 붙이면 16진수를 10진수로 변환해서 계산값에 넣겠습니다. 
    //라는 뜻
    
    int iBuf = iAttack | iHP | iCritical; // 10101 -> 버프를 건거임.
    cout << " Attack 버프가 걸려있는가 : " << (iBuf & iAttack) <<endl; // 비트 연산을 통해 버프 걸려있는지 확인  => 10101 & 1 => 00001 True
    cout << " armor 버프가 걸려있는가 : " << (iBuf & iArmor) <<endl;
    cout << " HP 버프가 걸려있는가 : " << (iBuf & iHP) <<endl;
    cout << " MP 버프가 걸려있는가 : " << (iBuf & iMP) <<endl;
    cout << " Critical 버프가 걸려있는가 : " << (iBuf & iCritical) <<endl;
    
    
    
    
    // 연산자 축약형 : 연산자를 줄여서 사용할 수 있음.
    // int iBuf ^= iHP; XOR 사용
    // 위를 풀어서 쓰면 iBuf = iBuf ^ iHP;
    // 10101 ^ = 00100 = 10001  
    // 쓰다 보니 XOR( ^ )은 1을 키고 끌 때 사용.
    // 그래서 걸려있는 버프를 끌때는 이 XOR을 이용하여 끈다.
    
    //버프 끄기
    iBuf ^= iHP; //버프 끄기 연산
    cout << " HP 버프가 걸려있는가 : " << (iBuf & iHP) <<endl;
    
    //버프 다시 키기
    iBuf ^=iHP; //버프 다시 키기 연산
    cout << " HP 버프가 걸려있는가 : " << (iBuf & iHP) <<endl;
    
    ------------------------------------------------------------
          
    쉬프트 연산자  
    : << , >> , 값 대 값을 연산하여 값으로 나오게 된다.
    이 연산자 또한 이진수 단위의 연산을 하게 된다.
    
    ex) 20 << 2  = 80  // 
        10진수 '20'을 2진수로 변환 -> 10100
        <<2 : 왼쪽으로 2칸 가라 
        => 1010000 
        다시 10진수로 바꾸면 '80'
        
        20<< 3 = 160
        10100000
        
    *** 따지고보면 20 x 2^2 = 80
                 20 x 2^3 = 160 ..
        이기에 << 연산을 빠른곱셈 이라고 한다.
        일반적인 연산보다 속도가 빠름!!
        
        
        20 >> 2 = 5
        10100 오른쪽에 있는 거 2개 지우라는 뜻 
        => 101
        
        20>> 3 = 2
        => 10
        
        이것도 마찬가지로 빠른나누기 라고 한다.
        
        ------------------------------------
    // 증감연산자 : ++, -- 가 있다. 1증가, 1감소
    전치, 후치
    후치는 대입 연산자 보다도 느리다.
          */
    
    
    
}